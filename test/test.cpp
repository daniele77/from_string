/*******************************************************************************
 * d77 from_string - C++14 conversion from string to any type.
 * Copyright (C) 2020 Daniele Pallastrelli
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

#define CATCH_CONFIG_MAIN  // This tells Catch to provide a main() - only do this in one cpp file
#include "catch.hpp"
#include "d77/from_string.h"

using namespace std;
using namespace d77;

namespace {

void inc(string& num)
{
    bool carry = true;
    for (auto rit = num.rbegin(); rit != num.rend(); ++rit)
    {
        if (carry)
        {
            if ( *rit == '9' )
                *rit = '0';
            else
            {
                *rit = (*rit) + 1;
                carry = false;
            }
        }
    }
    if (carry)
        num = '1' + num;
}

template <typename T>
struct signed_overflow
{
    static_assert(std::is_signed<T>::value, "Requires signed type");

    // return max as T and as string
    static constexpr pair<T,string> max()
    {
        const T value = numeric_limits<T>::max();
        return make_pair(value, to_string(value));
    }
    // return a string of max+1
    static constexpr string max_overflow()
    {
        const T max = numeric_limits<T>::max();
        string result = to_string(max);
        inc(result);
        return result;
    }
    // return min as T and as string
    static constexpr pair<T,string> min()
    {
        const T value = numeric_limits<T>::min();
        return make_pair(value, to_string(value));
    }
    // return a string of min-1
    static constexpr string min_overflow()
    {
        const T min = numeric_limits<T>::min();
        string result = to_string(min);
        result.substr(1); // remove the '-'
        inc(result);
        return '-' + result;
    }
};

template <typename T>
struct unsigned_overflow
{

    static_assert(std::is_unsigned<T>::value, "Requires unsigned type");

    // return max as T and as string
    static constexpr pair<T,string> max()
    {
        const unsigned long long int value = numeric_limits<T>::max();
        return make_pair(value, to_string(value));
    }
    // return a string of max+1
    static constexpr string max_overflow()
    {
        const unsigned long long int max = numeric_limits<T>::max();
        string result = to_string(max);
        inc(result);
        return result;
    }
};

}

TEST_CASE( "Test nullptr", "[nullptr]" )
{
    auto x = from_string<nullptr_t>("42");
    STATIC_REQUIRE(std::is_same<decltype(x), nullptr_t>::value);
    CHECK(x == nullptr);
}

// signed

TEST_CASE( "Test short int", "[short int]" )
{
    using Type = short int;

    auto x = from_string<Type>("42");
    STATIC_REQUIRE(std::is_same<decltype(x), Type>::value);
    CHECK(x == 42);

    CHECK(from_string<Type>("-42") == -42);
    CHECK(from_string<Type>("+42") == 42);
    CHECK(from_string<Type>("0") == 0);
    CHECK(from_string<Type>("0000") == 0);
    auto max = signed_overflow<Type>::max();
    CHECK(from_string<Type>(max.second) == max.first);
    auto min = signed_overflow<Type>::min();
    CHECK(from_string<Type>(min.second) == min.first);

    CHECK_THROWS_AS(from_string<Type>(""), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(" 42 "), bad_cast);

    CHECK_THROWS_AS(from_string<Type>(signed_overflow<Type>::max_overflow()), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(signed_overflow<Type>::min_overflow()), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(to_string(numeric_limits<Type>::max()) + "0"), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(to_string(numeric_limits<Type>::min()) + "0"), bad_cast);
}


TEST_CASE( "Test int", "[int]" )
{
    using Type = int;

    auto x = from_string<Type>("42");
    STATIC_REQUIRE(std::is_same<decltype(x), Type>::value);
    CHECK(x == 42);

    CHECK(from_string<Type>("-42") == -42);
    CHECK(from_string<Type>("+42") == 42);
    CHECK(from_string<Type>("0") == 0);
    CHECK(from_string<Type>("0000") == 0);
    auto max = signed_overflow<Type>::max();
    CHECK(from_string<Type>(max.second) == max.first);
    auto min = signed_overflow<Type>::min();
    CHECK(from_string<Type>(min.second) == min.first);

    CHECK_THROWS_AS(from_string<Type>(""), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(" 42 "), bad_cast);

    CHECK_THROWS_AS(from_string<Type>(signed_overflow<Type>::max_overflow()), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(signed_overflow<Type>::min_overflow()), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(to_string(numeric_limits<Type>::max()) + "0"), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(to_string(numeric_limits<Type>::min()) + "0"), bad_cast);
}

TEST_CASE( "Test long int", "[long int]" )
{
    using Type = long int;

    auto x = from_string<Type>("42");
    STATIC_REQUIRE(std::is_same<decltype(x), Type>::value);
    CHECK(x == 42);

    CHECK(from_string<Type>("-42") == -42);
    CHECK(from_string<Type>("+42") == 42);
    CHECK(from_string<Type>("0") == 0);
    CHECK(from_string<Type>("0000") == 0);
    auto max = signed_overflow<Type>::max();
    CHECK(from_string<Type>(max.second) == max.first);
    auto min = signed_overflow<Type>::min();
    CHECK(from_string<Type>(min.second) == min.first);

    CHECK_THROWS_AS(from_string<Type>(""), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(" 42 "), bad_cast);

    CHECK_THROWS_AS(from_string<Type>(signed_overflow<Type>::max_overflow()), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(signed_overflow<Type>::min_overflow()), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(to_string(numeric_limits<Type>::max()) + "0"), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(to_string(numeric_limits<Type>::min()) + "0"), bad_cast);
}

TEST_CASE( "Test long long int", "[long long int]" )
{
    using Type = long long int;

    auto x = from_string<Type>("42");
    STATIC_REQUIRE(std::is_same<decltype(x), Type>::value);
    CHECK(x == 42);

    CHECK(from_string<Type>("-42") == -42);
    CHECK(from_string<Type>("+42") == 42);
    CHECK(from_string<Type>("0") == 0);
    CHECK(from_string<Type>("0000") == 0);
    auto max = signed_overflow<Type>::max();
    CHECK(from_string<Type>(max.second) == max.first);
    auto min = signed_overflow<Type>::min();
    CHECK(from_string<Type>(min.second) == min.first);

    CHECK_THROWS_AS(from_string<Type>(""), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(" 42 "), bad_cast);

    CHECK_THROWS_AS(from_string<Type>(signed_overflow<Type>::max_overflow()), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(signed_overflow<Type>::min_overflow()), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(to_string(numeric_limits<Type>::max()) + "0"), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(to_string(numeric_limits<Type>::min()) + "0"), bad_cast);
}

TEST_CASE( "Test signed char", "[signed char]" )
{
    using Type = signed char;

    auto x = from_string<Type>("42");
    STATIC_REQUIRE(std::is_same<decltype(x), Type>::value);
    CHECK(x == 42);

    CHECK(from_string<Type>("-42") == -42);
    CHECK(from_string<Type>("+42") == 42);
    CHECK(from_string<Type>("0") == 0);
    CHECK(from_string<Type>("0000") == 0);
    auto max = signed_overflow<Type>::max();
    CHECK(from_string<Type>(max.second) == max.first);
    auto min = signed_overflow<Type>::min();
    CHECK(from_string<Type>(min.second) == min.first);
    CHECK_THROWS_AS(from_string<Type>(""), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(" 42 "), bad_cast);

    CHECK_THROWS_AS(from_string<Type>(signed_overflow<Type>::max_overflow()), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(signed_overflow<Type>::min_overflow()), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(to_string(numeric_limits<Type>::max()) + "0"), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(to_string(numeric_limits<Type>::min()) + "0"), bad_cast);
}

// unsigned

TEST_CASE( "Test unsigned short int", "[unsigned short int]" )
{
    using Type = unsigned short int;

    auto x = from_string<Type>("42");
    STATIC_REQUIRE(std::is_same<decltype(x), Type>::value);
    CHECK(x == 42);

    CHECK_THROWS_AS(from_string<Type>("-42"), bad_cast);
    CHECK(from_string<Type>("+42") == 42);
    CHECK(from_string<Type>("0") == 0);
    CHECK(from_string<Type>("0000") == 0);
    auto max = unsigned_overflow<Type>::max();
    CHECK(from_string<Type>(max.second) == max.first);

    CHECK_THROWS_AS(from_string<Type>(""), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(" 42 "), bad_cast);

    CHECK_THROWS_AS(from_string<Type>(unsigned_overflow<Type>::max_overflow()), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(to_string(static_cast<unsigned int>(numeric_limits<Type>::max())) + "0"), bad_cast);
}

TEST_CASE( "Test unsigned int", "[unsigned int]" )
{
    using Type = unsigned int;

    auto x = from_string<Type>("42");
    STATIC_REQUIRE(std::is_same<decltype(x), Type>::value);
    CHECK(x == 42);

    CHECK_THROWS_AS(from_string<Type>("-42"), bad_cast);
    CHECK(from_string<Type>("+42") == 42);
    CHECK(from_string<Type>("0") == 0);
    CHECK(from_string<Type>("0000") == 0);
    auto max = unsigned_overflow<Type>::max();
    CHECK(from_string<Type>(max.second) == max.first);

    CHECK_THROWS_AS(from_string<Type>(""), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(" 42 "), bad_cast);

    CHECK_THROWS_AS(from_string<Type>(unsigned_overflow<Type>::max_overflow()), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(to_string(numeric_limits<Type>::max()) + "0"), bad_cast);
}

TEST_CASE( "Test unsigned long int", "[unsigned long int]" )
{
    using Type = unsigned long int;

    auto x = from_string<Type>("42");
    STATIC_REQUIRE(std::is_same<decltype(x), Type>::value);
    CHECK(x == 42);

    CHECK_THROWS_AS(from_string<Type>("-42"), bad_cast);
    CHECK(from_string<Type>("+42") == 42);
    CHECK(from_string<Type>("0") == 0);
    CHECK(from_string<Type>("0000") == 0);
    auto max = unsigned_overflow<Type>::max();
    CHECK(from_string<Type>(max.second) == max.first);

    CHECK_THROWS_AS(from_string<Type>(""), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(" 42 "), bad_cast);

    CHECK_THROWS_AS(from_string<Type>(unsigned_overflow<Type>::max_overflow()), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(to_string(numeric_limits<Type>::max()) + "0"), bad_cast);
}

TEST_CASE( "Test unsigned long long int", "[unsigned long long int]" )
{
    using Type = unsigned long long int;

    auto x = from_string<Type>("42");
    STATIC_REQUIRE(std::is_same<decltype(x), Type>::value);
    CHECK(x == 42);

    CHECK_THROWS_AS(from_string<Type>("-42"), bad_cast);
    CHECK(from_string<Type>("+42") == 42);
    CHECK(from_string<Type>("0") == 0);
    CHECK(from_string<Type>("0000") == 0);
    auto max = unsigned_overflow<Type>::max();
    CHECK(from_string<Type>(max.second) == max.first);

    CHECK_THROWS_AS(from_string<Type>(""), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(" 42 "), bad_cast);

    CHECK_THROWS_AS(from_string<Type>(unsigned_overflow<Type>::max_overflow()), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(to_string(numeric_limits<Type>::max()) + "0"), bad_cast);
}

TEST_CASE( "Test unsigned char", "[unsigned char]" )
{
    using Type = unsigned char;

    auto x = from_string<Type>("42");
    STATIC_REQUIRE(std::is_same<decltype(x), Type>::value);
    CHECK(x == 42);

    CHECK_THROWS_AS(from_string<Type>("-42"), bad_cast);
    CHECK(from_string<Type>("+42") == 42);
    CHECK(from_string<Type>("0") == 0);
    CHECK(from_string<Type>("0000") == 0);
    auto max = unsigned_overflow<Type>::max();
    CHECK(from_string<Type>(max.second) == max.first);

    CHECK_THROWS_AS(from_string<Type>(""), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(" 42 "), bad_cast);

    CHECK_THROWS_AS(from_string<Type>(unsigned_overflow<Type>::max_overflow()), bad_cast);
    CHECK_THROWS_AS(from_string<Type>(to_string(static_cast<int>(numeric_limits<Type>::max())) + "0"), bad_cast);
}

// test boolean

TEST_CASE("conversion_to_bool", "[conversion_to_bool]")
{
    auto b1 = from_string<bool>("0");
    STATIC_REQUIRE(std::is_same<decltype(b1), bool>::value);
    CHECK_FALSE(b1);

    auto b2 = from_string<bool>("1");
    STATIC_REQUIRE(std::is_same<decltype(b2), bool>::value);
    CHECK(b2);

    auto b3 = from_string<bool>("false");
    STATIC_REQUIRE(std::is_same<decltype(b3), bool>::value);
    CHECK_FALSE(b3);

    auto b4 = from_string<bool>("true");
    STATIC_REQUIRE(std::is_same<decltype(b4), bool>::value);
    CHECK(b4);

    CHECK_THROWS_AS(from_string<bool>(""), bad_cast);
    CHECK_THROWS_AS(from_string<bool>(" 0"), bad_cast);
    CHECK_THROWS_AS(from_string<bool>("0 "), bad_cast);
    CHECK_THROWS_AS(from_string<bool>("a"), bad_cast);
    CHECK_THROWS_AS(from_string<bool>("A"), bad_cast);
    CHECK_THROWS_AS(from_string<bool>("2"), bad_cast);
    CHECK_THROWS_AS(from_string<bool>("-1"), bad_cast);
    CHECK_THROWS_AS(from_string<bool>("123"), bad_cast);
    CHECK_THROWS_AS(from_string<bool>("-123"), bad_cast);
    CHECK_THROWS_AS(from_string<bool>("Test"), bad_cast);

    CHECK(from_string<bool>("+1"));
    CHECK_FALSE(from_string<bool>("+0"));
    CHECK_FALSE(from_string<bool>("-0"));
    CHECK_THROWS_AS(from_string<bool>("--0"), bad_cast);
    CHECK_THROWS_AS(from_string<bool>("-+-0"), bad_cast);

    CHECK_FALSE(from_string<bool>("00"));
    CHECK_FALSE(from_string<bool>("00000000000"));
    CHECK(from_string<bool>("000000000001"));
    CHECK_FALSE(from_string<bool>("+00"));
    CHECK_FALSE(from_string<bool>("-00"));
    CHECK(from_string<bool>("+00000000001"));

    CHECK_THROWS_AS(from_string<bool>("020"), bad_cast);
    CHECK_THROWS_AS(from_string<bool>("00200"), bad_cast);
    CHECK_THROWS_AS(from_string<bool>("-00200"), bad_cast);
    CHECK_THROWS_AS(from_string<bool>("+00200"), bad_cast);
    CHECK_THROWS_AS(from_string<bool>("000000000002"), bad_cast);
    CHECK_THROWS_AS(from_string<bool>("-1"), bad_cast);
    CHECK_THROWS_AS(from_string<bool>("-0000000001"), bad_cast);
    CHECK_THROWS_AS(from_string<bool>("00000000011"), bad_cast);
    CHECK_THROWS_AS(from_string<bool>("001001"), bad_cast);
    CHECK_THROWS_AS(from_string<bool>("-00000000010"), bad_cast);
    CHECK_THROWS_AS(from_string<bool>("-000000000100"), bad_cast);
}

// test char

TEST_CASE( "Test char", "[char]" )
{
    auto x = from_string<char>(" ");
    STATIC_REQUIRE(std::is_same<decltype(x), char>::value);
    CHECK(x == ' ');
    CHECK(from_string<char>(".") == '.');
    CHECK(from_string<char>("$") == '$');
    CHECK(from_string<char>("@") == '@');
    CHECK('\0' == from_string<char>(string({0})));
    CHECK('A' == from_string<char>("A"));
    CHECK_THROWS_AS(from_string<char>(""), bad_cast);
    CHECK_THROWS_AS(from_string<char>("Test"), bad_cast);
}

// test floating point

TEST_CASE("test float", "[float]")
{
    using Type = float;

    auto f = from_string<Type>("0");
    STATIC_REQUIRE(std::is_same<decltype(f), Type>::value);
    CHECK(f == 0);

    CHECK_THROWS_AS(from_string<Type>(" 1"), bad_cast);
    CHECK_THROWS_AS(from_string<Type>("1 "), bad_cast);
    CHECK_THROWS_AS(from_string<Type>("1 1"), bad_cast);

    CHECK(from_string<Type>("1") == Approx(1.0));
    CHECK_THROWS_AS(from_string<Type>("A"), bad_cast);
    CHECK(from_string<Type>("1.23") == Approx(1.23));
    CHECK(from_string<Type>("1.234567890") == Approx(1.234567890));
    CHECK_THROWS_AS(from_string<Type>(""), bad_cast);
    CHECK_THROWS_AS(from_string<Type>("Test"), bad_cast);

    CHECK(from_string<Type>(to_string(numeric_limits<Type>::lowest())) == numeric_limits<Type>::lowest());
    CHECK(from_string<Type>(to_string(numeric_limits<Type>::min())) <= numeric_limits<Type>::min() + numeric_limits<Type>::epsilon());
    CHECK(from_string<Type>(to_string(numeric_limits<Type>::min())) >= numeric_limits<Type>::min() - numeric_limits<Type>::epsilon());
    CHECK(from_string<Type>(to_string(numeric_limits<Type>::denorm_min())) <= numeric_limits<Type>::denorm_min() + numeric_limits<Type>::epsilon());
    CHECK(from_string<Type>(to_string(numeric_limits<Type>::denorm_min())) >= numeric_limits<Type>::denorm_min() - numeric_limits<Type>::epsilon());
    CHECK(from_string<Type>(to_string(numeric_limits<Type>::max())) == numeric_limits<Type>::max());
}

TEST_CASE("test double", "[double]")
{
    using Type = double;

    auto f = from_string<Type>("0");
    STATIC_REQUIRE(std::is_same<decltype(f), Type>::value);
    CHECK(f == 0);

    CHECK_THROWS_AS(from_string<Type>(" 1"), bad_cast);
    CHECK_THROWS_AS(from_string<Type>("1 "), bad_cast);
    CHECK_THROWS_AS(from_string<Type>("1 1"), bad_cast);

    CHECK(from_string<Type>("1") == Approx(1.0));
    CHECK_THROWS_AS(from_string<Type>("A"), bad_cast);
    CHECK(from_string<Type>("1.23") == Approx(1.23));
    CHECK(from_string<Type>("1.234567890") == Approx(1.234567890));
    CHECK_THROWS_AS(from_string<Type>(""), bad_cast);
    CHECK_THROWS_AS(from_string<Type>("Test"), bad_cast);

    CHECK(from_string<Type>(to_string(numeric_limits<Type>::lowest())) == numeric_limits<Type>::lowest());
    CHECK(from_string<Type>(to_string(numeric_limits<Type>::min())) <= numeric_limits<Type>::min() + numeric_limits<Type>::epsilon());
    CHECK(from_string<Type>(to_string(numeric_limits<Type>::min())) >= numeric_limits<Type>::min() - numeric_limits<Type>::epsilon());
    CHECK(from_string<Type>(to_string(numeric_limits<Type>::denorm_min())) <= numeric_limits<Type>::denorm_min() + numeric_limits<Type>::epsilon());
    CHECK(from_string<Type>(to_string(numeric_limits<Type>::denorm_min())) >= numeric_limits<Type>::denorm_min() - numeric_limits<Type>::epsilon());
    CHECK(from_string<Type>(to_string(numeric_limits<Type>::max())) == numeric_limits<Type>::max());
}

TEST_CASE("test long double", "[long double]")
{
    using Type = long double;

    auto f = from_string<Type>("0");
    STATIC_REQUIRE(std::is_same<decltype(f), Type>::value);
    CHECK(f == 0);

    CHECK_THROWS_AS(from_string<Type>(" 1"), bad_cast);
    CHECK_THROWS_AS(from_string<Type>("1 "), bad_cast);
    CHECK_THROWS_AS(from_string<Type>("1 1"), bad_cast);

    CHECK(from_string<Type>("1") == Approx(1.0));
    CHECK_THROWS_AS(from_string<Type>("A"), bad_cast);
    CHECK(from_string<Type>("1.23") == Approx(1.23));
    CHECK(from_string<Type>("1.234567890") == Approx(1.234567890));
    CHECK_THROWS_AS(from_string<Type>(""), bad_cast);
    CHECK_THROWS_AS(from_string<Type>("Test"), bad_cast);

    CHECK(from_string<Type>(to_string(numeric_limits<Type>::lowest())) == numeric_limits<Type>::lowest());
    CHECK(from_string<Type>(to_string(numeric_limits<Type>::min())) <= numeric_limits<Type>::min() + numeric_limits<Type>::epsilon());
    CHECK(from_string<Type>(to_string(numeric_limits<Type>::min())) >= numeric_limits<Type>::min() - numeric_limits<Type>::epsilon());
    CHECK(from_string<Type>(to_string(numeric_limits<Type>::denorm_min())) <= numeric_limits<Type>::denorm_min() + numeric_limits<Type>::epsilon());
    CHECK(from_string<Type>(to_string(numeric_limits<Type>::denorm_min())) >= numeric_limits<Type>::denorm_min() - numeric_limits<Type>::epsilon());
    CHECK(from_string<Type>(to_string(numeric_limits<Type>::max())) == numeric_limits<Type>::max());
}

// whitespaces

TEST_CASE("no_whitespace_stripping", "[no_whitespace_stripping]")
{
    CHECK_THROWS_AS(from_string<int>(" 123"), bad_cast);
    CHECK_THROWS_AS(from_string<int>("123 "), bad_cast);
    CHECK_THROWS_AS(from_string<int>("\t123"), bad_cast);
    CHECK_THROWS_AS(from_string<int>("123\n"), bad_cast);
}

// test operator overload

struct foo_operators_test
{
    foo_operators_test() : f(2) {}
    int f;
};

template <typename IStream>
IStream& operator>>(IStream& istr, foo_operators_test& foo)
{
    int tmp;
    istr >> tmp;
    if (tmp < 0)
        istr.setstate(std::ios_base::failbit);
    foo.f = tmp;
    return istr;
}

TEST_CASE("operators_overload_test", "[operators_overload_test]")
{
    CHECK((from_string<foo_operators_test>("2")).f == 2);
    CHECK_THROWS_AS(from_string<foo_operators_test>("-1"), bad_cast);
}
